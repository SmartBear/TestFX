/*
 * Copyright 2013-2014 SmartBear Software
 * Copyright 2014-2017 The TestFX Contributors
 *
 * Licensed under the EUPL, Version 1.1 or - as soon they will be approved by the
 * European Commission - subsequent versions of the EUPL (the "Licence"); You may
 * not use this work except in compliance with the Licence.
 *
 * You may obtain a copy of the Licence at:
 * http://ec.europa.eu/idabc/eupl
 *
 * Unless required by applicable law or agreed to in writing, software distributed
 * under the Licence is distributed on an "AS IS" basis, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the Licence for the
 * specific language governing permissions and limitations under the Licence.
 */

import org.gradle.api.tasks.testing.logging.TestExceptionFormat
import org.gradle.api.tasks.testing.logging.TestLogEvent

//-------------------------------------------------------------------------------------------------
// GRADLE PLUGINS.
//-------------------------------------------------------------------------------------------------

buildscript {
    repositories {
        jcenter()
    }
}

plugins {
    id "com.github.hierynomus.license" version "0.14.0"
    id "com.jfrog.bintray" version "1.8.0"
    id 'com.github.ben-manes.versions' version '0.17.0'
    id 'com.github.kt3k.coveralls' version '2.8.2'
}

rootProject.with { project ->
    // provide assemble and clean tasks.
    // task to add gradle wrapper files.
    task("wrapper", type: Wrapper) {
        gradleVersion = '4.3.1'
        distributionUrl = "https://services.gradle.org/distributions/" +
            "gradle-${gradleVersion}-all.zip"
    }

    // task to print gradle and groovy versions.
    task("versions", group: "help").doLast {
        println "JAVA_OPTS: ${System.env.JAVA_OPTS}"
        println "JAVA_HOME: ${System.env.JAVA_HOME}"
        println "Java version: ${System.properties["java.version"]}"
        println "Gradle version: ${gradle.gradleVersion}"
        println "Groovy version: ${GroovySystem.version}"
        println "Included projects are: ${rootProject.childProjects.keySet()}"
    }

    ext {
        // add build time and date to project attributes.
        def buildTimeAndDate = new Date()
        buildDate = buildTimeAndDate.format("yyyy-MM-dd")
        buildTime = buildTimeAndDate.format("HH:mm:ss.SSSZ")

        // add java version and vendor to project attributes.
        javaVersion = System.properties["java.version"]
        usingJava9 = javaVersion.startsWith("9")
        javaSourceCompat = usingJava9 ? "9" : "1.8"
    }
}

allprojects { project ->
    apply plugin: 'base'
    apply plugin: 'java'
    apply plugin: 'com.github.kt3k.coveralls'
    apply plugin: 'jacoco'
    apply from: "${rootDir}/gradle/jacoco.gradle"
    apply from: "${rootDir}/gradle/travis-helpers.gradle"

    configurations {
        providedCompile
    }

    repositories {
        if (project.hasProperty("useMavenLocal")) {
            mavenLocal()
        }
        jcenter()
    }
}

subprojects { subproject ->
    apply plugin: 'osgi'

    if (!usingJava9) {
        apply from: "${rootDir}/gradle/findbugs.gradle"
    }
    //apply(from: rootProject.file("gradle/jdepend.gradle"))
    apply from: "${rootDir}/gradle/checkstyle.gradle"
    apply from: "${rootDir}/gradle/license.gradle"
    apply from: "${rootDir}/gradle/publish-jar.gradle"
    apply from: "${rootDir}/gradle/publish-maven.gradle"
    apply from: "${rootDir}/gradle/publish-bintray.gradle"

    sourceSets.main.compileClasspath += configurations.providedCompile
    sourceSets.test.compileClasspath += configurations.providedCompile
    sourceSets.test.runtimeClasspath += configurations.providedCompile

    task("sourceJar", type: Jar) {
        group "Build"
        description "An archive of the source code"
        classifier "sources"
        from sourceSets.main.allJava
    }

    task("javadocJar", type: Jar) {
        group "Build"
        description "An archive of the javadoc"
        classifier "javadoc"
        from javadoc
    }

    jar.finalizedBy sourceJar
    jar.finalizedBy javadocJar

    artifacts {
        sourceJar
        javadocJar
    }

    sourceCompatibility = javaSourceCompat
    targetCompatibility = javaSourceCompat

    // use utf-8 encoding for java compile.
    tasks.withType(JavaCompile) {
        options.encoding = "UTF-8"
    }

    test {
        reports.junitXml.destination = file("$projectDir/../../build/test-reports/xml")
        testLogging {
            // Fancy formatting from http://stackoverflow.com/a/36130467/3634630
            // set options for log level LIFECYCLE
            events TestLogEvent.PASSED, TestLogEvent.SKIPPED,
                TestLogEvent.FAILED, TestLogEvent.STANDARD_OUT
            showExceptions true
            exceptionFormat TestExceptionFormat.FULL
            showCauses true
            showStackTraces true

            // set options for log level DEBUG and INFO
            debug {
                events TestLogEvent.STARTED, TestLogEvent.PASSED,
                    TestLogEvent.SKIPPED, TestLogEvent.FAILED,
                    TestLogEvent.STANDARD_OUT, TestLogEvent.STANDARD_ERROR
            }
            info.events = debug.events
            def tuple
            beforeSuite { desc ->
                if (!desc.parent) { // will match the outermost suite
                    travisFoldStart(desc.name)
                    tuple = travisTimerStart()
                }
            }
            afterSuite { desc, result ->
                if (!desc.parent) { // will match the outermost suite
                    if (tuple != null) {
                        travisTimerEnd(tuple.first, tuple.second)
                    }
                    def output = "Results: ${result.resultType} (${result.testCount} tests, ${result.successfulTestCount} successes, ${result.failedTestCount} failures, ${result.skippedTestCount} skipped)"
                    def startItem = '|  ', endItem = '  |'
                    def repeatLength = startItem.length() + output.length() + endItem.length()
                    println('\n' + ('-' * repeatLength) + '\n' + startItem + output + endItem + '\n' + ('-' * repeatLength))
                    travisFoldEnd(desc.name)
                }
            }
        }
    }
}

evaluationDependsOnChildren()

ext {
    if (usingJava9) {
        javadocLinks = [
                "https://docs.oracle.com/javase/9/docs/api"
        ]
    } else {
        javadocLinks = [
                "http://docs.oracle.com/javase/8/docs/api/",
                "http://docs.oracle.com/javase/8/javafx/api/"
        ]
    }
}

subprojects { subproject ->
    javadoc {
        excludes = ["**/*.html", "META-INF/**"]
        classpath = configurations.compile + configurations.providedCompile + configurations.compileOnly
        options.use         = true
        options.splitIndex  = true
        options.encoding    = "UTF-8"
        options.author      = true
        options.version     = subproject.sourceCompatibility
        options.windowTitle = "${subproject.name} ${version} API"
        options.docTitle    = "${subproject.name} ${version} API"
        options.footer      = project.javadocFooter
        options.links       = javadocLinks
        options.noTimestamp = true
        options.addStringOption("Xdoclint:none", "-quiet")
    }
}

task aggregateJavadoc(type: Javadoc) {
    group "Documentation"
    description "Generates aggregated Javadoc API documentation."

    def javadocSubprojects = subprojects.findAll { project ->
        project.sourceSets.main.allJava.matching { include "org/testfx/**" }.with { !it.empty }
    }

    source javadocSubprojects.collect { project ->
        project.sourceSets.main.allJava
    }
    classpath = files(javadocSubprojects.collect { project ->
        project.sourceSets.main.compileClasspath
    })

    title "${project.javadocName} ${project.version} API"
    destinationDir = new File(projectDir, "docs/javadoc")

    configure(options) {
        use = true
        splitIndex = true
        encoding = "UTF-8"
        links = javadocLinks
    }

    // disable java 8 overly pedantic lint checking.
    if (JavaVersion.current().isJava8Compatible()) {
        options.addStringOption("Xdoclint:none", "-quiet")
    }

    doFirst {
        project.delete(destinationDir)
        logger.info "Title    : ${options.windowTitle}"
        logger.info "Destdir  : ${destinationDir}"
    }
}

task jacocoMerge(type: JacocoMerge) {
    destinationFile = file("$buildDir/jacoco/jacoco-all.exec")
    subprojects.each { subproject ->
        executionData subproject.tasks.withType(Test)
    }
    doFirst {
        executionData = files(executionData.findAll { it.exists() })
    }
}

task jacocoRootReport(type: JacocoReport, group: 'Coverage reports') {
    description = 'Generates an aggregate report from all subprojects'
    dependsOn subprojects.test, jacocoMerge
    additionalSourceDirs = files(subprojects.sourceSets.main.allSource.srcDirs)
    sourceDirectories = files(subprojects.sourceSets.main.allSource.srcDirs)
    classDirectories = files(subprojects.sourceSets.main.output)
    executionData = files(subprojects.jacocoTestReport.executionData).filter { it.exists() }

    reports {
        html.enabled = true
        xml.enabled = true
    }
}

coveralls {
    sourceDirs = subprojects.sourceSets.main.allSource.srcDirs.flatten()
    jacocoReportPath = "${buildDir}/reports/jacoco/jacocoRootReport/jacocoRootReport.xml"
}

tasks.coveralls {
    group = 'Coverage reports'
    description = 'Uploads the aggregated coverage report to Coveralls'
    logging.setLevel(LogLevel.LIFECYCLE)

    dependsOn jacocoRootReport
    onlyIf { isTravis && !JavaVersion.current().isJava9Compatible() }
}
